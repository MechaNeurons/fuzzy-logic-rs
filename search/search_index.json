{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"fuzzy-logic_rs","text":"<p>This is the documentation for fuzzy logic crate.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>    cargo add fuzzy-logic_rs\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>src/\n    lib.rs\n    aggregations.rs\n    defuzzification.rs\n    fuzzy_inference_systems.rs\n    implications.rs\n    membership_functions.rs\n    membership_ranges.rs\n    rules.rs\n    s_norms.rs\n    t_norms.rs\n    variables.rs\nexamples/\n    function_approximation.rs\n    speed_control.rs\n    tipper.rs\nCargo.toml\n.gitignore\nreadme.md\nLICENSE\n-- mkdocs files\n</code></pre>"},{"location":"#inference-systems","title":"Inference Systems","text":"<ul> <li> Mamdani Type 1</li> <li> Mamdani Type 2</li> <li> TSK Type 1</li> <li> TSK Type 2</li> </ul>"},{"location":"#future-plans","title":"Future Plans","text":"<ul> <li> Import and Export systems to and from a file</li> <li> Add plot support</li> <li> add meta-heuristics</li> <li> add ANFIS support</li> <li> add dedicated control module</li> <li> add fuzzy c-means</li> </ul>"},{"location":"examples/","title":"Example Lists","text":"<ul> <li> <p>tipper   Typical tipping problem solved using Mamdani type 1.</p> </li> <li> <p>speed control    Mamdani type1 used to control the acceleration of a car.</p> </li> <li> <p>Function approximation   TSK type1 system used to approximate the function \\(f(x) = x(1-x)\\) where \\(x\\in[0,1]\\)</p> </li> </ul>"},{"location":"docs/doc1/","title":"Functions and Structs and Enums","text":""},{"location":"docs/doc1/#fuzzy_inference_systemsrs","title":"fuzzy_inference_systems.rs","text":""},{"location":"docs/doc1/#mamdanifis","title":"MamdaniFIS","text":"<p>This is Mamdani Inference system</p> <pre><code>pub struct MamdaniFuzzyInferenceSystem {\ns_norm: SNorms,\nt_norm: TNorms,\nimplication: Implications,\naggregation: Aggregations,\ndefuzzifier: Defuzzifiers,\nrules: Vec&lt;Rule&gt;,\ninputs: Vec&lt;InputVariable&gt;,\noutputs: Vec&lt;OutputVariable&gt;,\n}\n</code></pre> <p>You can create a this system using <code>::new</code> method witch is defined as</p> <pre><code>pub fn new(\n        s_norm: SNorms,\n        t_norm: TNorms,\n        implication: Implications,\n        aggregation: Aggregations,\n        defuzzifier: Defuzzifiers,\n    ) -&gt; Self\n</code></pre> <p>Each of these fields are documented separately.</p> <p>To add an input you must use <code>add_input</code> method. It needs an <code>InputVariables</code>.</p> <pre><code>pub fn add_input(&amp;mut self, input: InputVariable)\n</code></pre> <p>The same is true for output but it needs an <code>OutputVariables</code>.</p> <pre><code>pub fn add_output(&amp;mut self, output: OutputVariable)\n</code></pre> <p>To add fuzzy rules you can use <code>add_rule</code> which accepts a <code>Rule</code> struct as an input</p> <pre><code>pub fn add_rule(&amp;mut self, rule: Rule)\n</code></pre> <p>After defining the instance, inputs, outputs, and rules, you can use compute the system output using the <code>compute_output</code> which excepts a <code>vec&lt;f64&gt;</code> of input variables and outputs a <code>vec&lt;f64&gt;</code> containing output variables.</p> <p>Note</p> <p>please note that the inputs must be in the order of when you use <code>add_input</code> method, and outputs will be in the same order as you add them.</p> <pre><code>pub fn compute_outputs(&amp;self, input_vec: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt;\n</code></pre>"},{"location":"docs/doc1/#tskfis","title":"TSKFIS","text":"<p>This is TSK Inference system.</p> <pre><code>pub struct TSKFuzzyInferenceSystem {\n    s_norm: SNorms,\n    t_norm: TNorms,\n    defuzzification: TSKDefuzzifiers,\n    rules: Vec&lt;Rule&gt;,\n    inputs: Vec&lt;InputVariable&gt;,\n    outputs: Vec&lt;TSKOutputVariable&gt;,\n}\n\npub type TSKFIS = TSKFuzzyInferenceSystem;\n</code></pre> <p>You can create a this system using <code>::new</code> method witch is defined as:</p> <pre><code>pub fn new(\n    s_norm: SNorms, \n    t_norm: TNorms, \n    defuzzification: TSKDefuzzifiers\n    ) -&gt; Self \n</code></pre> <p>Each of these fields are documented separately.</p> <p>To add an input you must use <code>add_input</code> method. It needs an <code>InputVariables</code>.</p> <pre><code>pub fn add_input(&amp;mut self, input: InputVariable)\n</code></pre> <p>The same is true for output but it needs an <code>TSKOutputVariables</code>.</p> <pre><code>pub fn add_output(&amp;mut self, output: TSKOutputVariable)\n</code></pre> <p>To add fuzzy rules you can use <code>add_rule</code> which accepts a <code>Rule</code> struct as an input</p> <pre><code>pub fn add_rule(&amp;mut self, rule: Rule)\n</code></pre> <p>After defining the instance, inputs, outputs, and rules, you can use compute the system output using the <code>compute_output</code> which excepts a <code>vec&lt;f64&gt;</code> of input variables and outputs a <code>vec&lt;f64&gt;</code> containing output variables.</p> <pre><code>pub fn compute_outputs(&amp;self, input_vec: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt;\n</code></pre>"},{"location":"docs/doc1/#s_normsrs","title":"s_norms.rs","text":"<p>S-norms are used in FIS systems to compute many thing. In this crate I used it as <code>or</code> method in the rules. It is defined as bellow:</p> <pre><code>pub enum SNorms {\n    Max,\n    Custom(fn (&amp;[f64])-&gt;f64),\n}\n</code></pre> <p>To use default s-norms you can use the <code>Snorms::Max</code>.</p> <p>Right now only <code>Max</code> is defined by default, but you can add a custom s-norm method by defining a function who's signature is like the enum.</p>"},{"location":"docs/doc1/#t_normsrs","title":"t_norms.rs","text":"<p>T-norms are used in FIS systems to compute many thing. In this crate I used it as <code>and</code> method in the rules. You can use t-norms as the same as s-norms.</p> <pre><code>pub enum TNorms {\n    Min,\n    Product,\n    Custom(fn(&amp;[f64]) -&gt; f64),\n}\n</code></pre>"},{"location":"docs/doc1/#implicationsrs","title":"implications.rs","text":"<p>Implication is the act of computing the overall membership of the rule for example</p> \\[ IF \\ x_1 \\ IS \\ \\mu_1 \\ AND \\ x_2 \\ IS \\mu_2 \\ THEN \\ output \\ IS \\ \\mu_o \\] <p>In this form the output of implication is how much the IF part belong to this rule and how is the output membership looks. It is defined as:</p> <pre><code>pub enum Implications {\n    Min,\n    Product,\n    Custom(fn(f64, &amp;Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt;),\n}\n</code></pre> <p>More Implication methods</p> <p>More implication methods will be added in the future like <code>Godel</code> or <code>Zadeh</code>.</p> <p>Use of this is the same as t-norms and s-norms and you can define your own methods for implications.</p> <p>The 1st parameter of the custom function is \\(\\mu\\) and the 2nd argument is an output range.</p>"},{"location":"docs/doc1/#rulesrs","title":"rules.rs","text":"<p>You can define a rule whit:</p> <pre><code>pub struct Rule {\n    relations: Vec&lt;i32&gt;,\n    weight: f64,\n    method: Kind,\n}\n</code></pre> <p>there are two ways to add new rules <code>add_or</code> and <code>add_and</code>. The relations vec is defined as in a rule how the inputs interact with each other.</p> <p>You can change the weight to a value between [0.0 1.0].</p> <p>You can complement(i.e. <code>is not</code>) a membership function or a range by adding a <code>-</code> sign in front of it.</p>"},{"location":"docs/doc1/#aggregationrs","title":"aggregation.rs","text":"<p>Aggregation is the how to compute the overall membership of the output. Basically each rule will produce a range and how to convert them to a single membership range is the overall shape will looks.</p> <pre><code>pub enum Aggregations {\n    Max,\n    Sum,\n    Custom(fn(Vec&lt;Vec&lt;f64&gt;&gt;) -&gt; Vec&lt;f64&gt;)\n}\n</code></pre> <p>You can use it just like previous methods.</p>"},{"location":"docs/doc1/#defuzzificationrs","title":"defuzzification.rs","text":"<p>This is the process in which the fuzzy number is converted back to a crisp number.</p> <pre><code>pub enum Defuzzifiers {\n    Centroid,\n    Bisection,\n    Custom(fn(Vec&lt;f64&gt;,&amp;Vec&lt;f64&gt;)-&gt;f64),\n}\n</code></pre> <p>It is used as before.</p> <p>More defuzzification methods</p> <p>More defuzzification method will be added in the future like <code>CenterOfMeans</code> or <code>MeanOfMax</code>.</p> <p>For TSK systems there are other defuzzification method so we have to use another enum.</p> <pre><code>pub enum TSKDefuzzifiers {\n    Mean,\n    Custom(fn(&amp;Vec&lt;f64&gt;, &amp;Vec&lt;f64&gt;) -&gt; f64),\n}\n</code></pre>"},{"location":"docs/doc1/#variablesrs","title":"variables.rs","text":""},{"location":"docs/doc1/#inputvariable","title":"InputVariable","text":"<p>To define a input variable you have to use this struct.</p> <pre><code>pub struct InputVariable {\n    name: String,\n    range: (f64, f64),\n    mfs: Vec&lt;MembershipFunction&gt;,\n}\n</code></pre> <p>You need to use <code>::new()</code> to make a new input variable. Range is the range in which this variable is valid.</p> <p>range</p> <p>There is no restrictions on range now but in the future this will change.</p> <pre><code>pub fn new(name: String, range: (f64, f64)) -&gt; Self \n</code></pre> <p>You can add new membership to a variable. Please note that in need to be a <code>MembershipFunction</code></p> <pre><code>pub fn add_membership(&amp;mut self, mf: MembershipFunction)\n</code></pre> <p>To fuzzify a variable(i.e. convert it from a crisp set to a fuzzy set) you can use the function below. This function will get an index of which membership function you want to fuzzify and the value that need to be converted.</p> <pre><code>pub fn fuzzify(&amp;self, idx: usize, x: f64) -&gt; f64 \n</code></pre>"},{"location":"docs/doc1/#outputvariable","title":"OutputVariable","text":"<p>To define an output variable you need to use this struct. It has a vec of membership range and a universe. The <code>universe</code> it the range in which the output is defined and <code>mrs</code> are the ranges of different memberships. Please note that any value outside of <code>universe</code> is not defined.</p> <pre><code>pub struct OutputVariable {\n    name: String,\n    mrs: Vec&lt;MembershipRange&gt;,\n    universe: Vec&lt;f64&gt;,\n}\n</code></pre> <p>You can create a new <code>OutputVariable</code> using <code>::new()</code> which need a range where the universe is defined and, and how many number of points you want tou be in the range whit <code>n</code> argument.</p> <pre><code>pub fn new(name: String, range: (f64, f64), n: i32) -&gt; Self\n</code></pre>"},{"location":"docs/doc1/#tskoutputvariable","title":"TSKOutputVariable","text":"<p>This struct is used for creating a TSK output variable. </p> <pre><code>pub struct TSKOutputVariable {\n    name: String,\n    mfs: Vec&lt;TSKMembershipFunction&gt;,\n}\n</code></pre> <p>By using <code>::new()</code> you can create a new instance.</p> <pre><code>pub fn new(name: String) -&gt; Self \n</code></pre> <p>You can add <code>constant</code> , <code>linear</code> or custom membership function by calling <code>add</code> methods.</p> <pre><code>pub fn add_membership(&amp;mut self, membership: TSKMembershipFunction) {\n    self.mfs.push(membership);\n}\n\npub fn add_constant_membership(&amp;mut self, value: f64) {\n    self.mfs.push(TSKMembershipFunction::Constant(value));\n}\n\npub fn add_linear_membership(&amp;mut self, coefficients: Vec&lt;f64&gt;) {\n    self.mfs.push(TSKMembershipFunction::Linear(coefficients));\n}\n</code></pre>"},{"location":"docs/doc1/#membership_functionsrs","title":"membership_functions.rs","text":"<p>This file will defined the membership functions that is used in input variable. Several defaults are defined but you can also define your own.</p> <pre><code>pub struct MembershipFunction {\n    name: String,\n    kind: Kind,\n}\n</code></pre> <p><code>kind</code> is the kind of membership function that you want to use and it defined as an enum.</p> <pre><code>pub enum Kind {\n    Triangle(Triangle),\n    Trapezoid(Trapezoid),\n    LinearZ(LinearZ),\n    LinearS(LinearS),\n    StepDown(StepDown),\n    StepUp(StepUp),\n    Gaussian(Gaussian),\n    DoubleGaussian(DoubleGaussian),\n    Bell(Bell),\n    Normal(Gaussian),\n    Custom(Custom),\n}\n</code></pre> <p>Each of these variants have a dedicated struct that you can make using <code>::new()</code>.</p> <p>For TSK systems you have to use this enum.</p> <pre><code>pub enum TSKMembershipFunction {\n    Constant(f64),\n    Linear(Vec&lt;f64&gt;),\n    Custom(fn(&amp;Vec&lt;f64&gt;) -&gt; f64),\n}\n</code></pre>"},{"location":"docs/doc1/#membership_rangesrs","title":"membership_ranges.rs","text":"<p>Membership ranges are used to define an output.</p> <pre><code>pub struct MembershipRange {\n    name: String,\n    mu: Vec&lt;f64&gt;,\n}\n</code></pre>"},{"location":"docs/doc1/#creating-a-membership-function-or-membership-range","title":"Creating a membership function or membership range","text":"<p>They have basically the same. You can create a new using the syntax <code>::new_&lt;what_kind&gt;</code> and add appropriate arguments to it. Please follow the function signature or check out the example for more information.</p>"},{"location":"examples/function_approximation/","title":"Overview","text":"<p>We want to approximate the function \\(f(x) = x(1-x)\\) where  \\(x \\in [0,1]\\)</p> <p>you can run the example with the following command.</p> <pre><code>cargo run --example function-approximation\n</code></pre>"},{"location":"examples/function_approximation/#problem-definition","title":"Problem Definition","text":"<p>We want to approximate the function in this specified domain with 5 points. I choose this 5 point to be equally spaced from each other. So the points are <code>X = [0.0,0.25,0.5,0.75,1.0]</code> by computing the original function in these points we can find <code>Y =[0.0,.1875,0.25,0.1875,0.0]</code>. We can see that this vector is symmetric so we can just use 3 of them instead of all 5.</p>"},{"location":"examples/function_approximation/#import","title":"Import","text":"<p>We will import the necessary modules:</p> <pre><code>use fuzzy_logic_rs::{\n    defuzzifications::TSKDefuzzifiers,\n    fuzzy_inference_systems::TSKFIS,\n    membership_functions::{Gaussian, MFKind, MembershipFunction},\n    rules::Rule,\n    s_norms::SNorms,\n    t_norms::TNorms,\n    variables::{InputVariable, TSKOutputVariable},\n};\n</code></pre>"},{"location":"examples/function_approximation/#setup","title":"Setup","text":"<p>First we add some variables and a closure to help us in the future.</p> <pre><code>let x1 = 0.0;\nlet x2 = 0.25;\nlet x3 = 0.5;\nlet x4 = 0.75;\nlet x5 = 1.0;\nlet original_function = |x| x * (1.0 - x);\nlet y15 = original_function(x1);\nlet y24 = original_function(x2);\nlet y3 = original_function(x3);\n</code></pre> <p>Then, we will using TSK FIS with the following configurations.</p> <pre><code>let mut fis = TSKFIS::new(SNorms::Max, TNorms::Min, TSKDefuzzifiers::Mean);\n</code></pre>"},{"location":"examples/function_approximation/#inputs","title":"Inputs","text":"<p>We have only on input that is <code>x</code>. We choose Gaussian membership function for all of this variables's membership function, and then add this variables to the system.</p> <pre><code>let mut x: InputVariable = InputVariable::new(\"X\".to_string(), (0.0, 1.0));\nx.add_membership(MembershipFunction::new(\n    \"x1\".to_string(),\n    MFKind::Gaussian(Gaussian::new(x1, 0.09)),\n));\nx.add_membership(MembershipFunction::new(\n    \"x2\".to_string(),\n    MFKind::Gaussian(Gaussian::new(x2, 0.09)),\n));\nx.add_membership(MembershipFunction::new(\n    \"x3\".to_string(),\n    MFKind::Gaussian(Gaussian::new(x3, 0.09)),\n));\nx.add_membership(MembershipFunction::new(\n    \"x4\".to_string(),\n    MFKind::Gaussian(Gaussian::new(x4, 0.09)),\n));\nx.add_membership(MembershipFunction::new(\n    \"x5\".to_string(),\n    MFKind::Gaussian(Gaussian::new(x5, 0.09)),\n));\nfis.add_input(x);\n</code></pre>"},{"location":"examples/function_approximation/#outputs","title":"Outputs","text":"<p>This function is only have one output. I choose 3 memberships because this function is symmetric about line \\(x=1\\) and the data is also symmetric. You can use 5 functions with no difference in output.</p> <pre><code>let mut y: TSKOutputVariable = TSKOutputVariable::new(\"Y\".to_string());\ny.add_constant_membership(y15);\ny.add_constant_membership(y24);\ny.add_constant_membership(y3);\n\nfis.add_output(y);\n</code></pre>"},{"location":"examples/function_approximation/#rules","title":"Rules","text":"<p>Rules for this problem is simple.</p> <ol> <li>IF x IS x1 THEN Y15.</li> <li>IF x IS x2 THEN Y24.</li> <li>IF x IS x3 THEN Y3.</li> <li>IF x IS x4 THEN Y24.</li> <li>IF x IS x5 THEN Y15.</li> </ol> <p>We can define the rules now:</p> <pre><code>fis.add_rule(Rule::new_and(vec![0, 0], 1.0));\nfis.add_rule(Rule::new_and(vec![1, 1], 1.0));\nfis.add_rule(Rule::new_and(vec![2, 2], 1.0));\nfis.add_rule(Rule::new_and(vec![3, 1], 1.0));\nfis.add_rule(Rule::new_and(vec![4, 0], 1.0));\n</code></pre> <p>Weights and Complements</p> <p>You can change weights and changing the second argument, and you can add <code>-</code> sign to complement that variables</p>"},{"location":"examples/function_approximation/#output","title":"Output","text":"<p>The problem formulation is done and we can use this to compute the output of the system:</p> <pre><code>let out: Vec&lt;f64&gt; = fis.compute_outputs(vec![0.6]);\nprintln!(\"{:?}\", out);\n</code></pre> <p>If we run it the output will be:</p> <pre><code>\u276f cargo run --example function-approximation\n   Compiling fuzzy-logic_rs v0.5.0 \n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/examples/function-approximation`\n[0.2301986089076184]\n</code></pre>"},{"location":"examples/function_approximation/#plot","title":"Plot","text":"<p>We can plot this approximation and compare it to the original function.</p> <p> You can add more points to improve its accuracy, but with only 5 points it gave us a good result.</p>"},{"location":"examples/speed_control/","title":"Overview","text":"<p>In This example we will solving a problem in which we want to control the acceleration of car.</p>"},{"location":"examples/speed_control/#run-the-example","title":"run the example","text":"<p>you can run the example with the following command.</p> <pre><code>cargo run --example speed-control\n</code></pre>"},{"location":"examples/speed_control/#problem-definition","title":"Problem Definition","text":"<p>Control the acceleration of a vehicle using data from speedometer and a radar that measures the distance between the ego vehicle and the vehicle in the front.</p>"},{"location":"examples/speed_control/#import","title":"Import","text":"<p>We will import the necessary modules:</p> <pre><code>use fuzzy_logic_rs::{\n    aggregations::Aggregations,\n    defuzzifications::Defuzzifiers,\n    fuzzy_inference_systems::MamdaniFIS,\n    implications::Implications,\n    membership_functions::{MFKind, Triangle, MF},\n    membership_ranges::MembershipRange,\n    rules::Rule,\n    s_norms::SNorms,\n    t_norms::TNorms,\n    variables::{InputVariable, OutputVariable},\n};\n</code></pre>"},{"location":"examples/speed_control/#setup","title":"Setup","text":"<p>We will using Mamdani FIS with the following configurations.</p> <pre><code>let mut fis = MamdaniFIS::new(\n        SNorms::Max,\n        TNorms::Min,\n        Implications::Min,\n        Aggregations::Max,\n        Defuzzifiers::Bisection,\n    );\n</code></pre>"},{"location":"examples/speed_control/#inputs","title":"Inputs","text":"<p>As the problem stated we have to input that we can use in our calculation, speed and distance. I'll assume the speed will vary in the range of [0 140] and distance in the range of [0 50].</p> <p>Input range</p> <p>please do not use the values outside of these ranges, in the current setup. change to the membership that are also defined outside of this range like <code>LinearZ</code> and <code>LinearS</code> or a custom one.</p> <p>I choose 3 triangular membership functions for each input.</p> <p>speed: S - M - L</p> <pre><code>let mut v1 = InputVariable::new(\"speed\".to_string(), (0.0, 140.0));\nv1.add_membership(MF::new(\n    \"S\".to_string(),\n    MFKind::Triangle(Triangle::new(-58.3, 0.0, 58.3)),\n));\nv1.add_membership(MF::new(\n    \"M\".to_string(),\n    MFKind::Triangle(Triangle::new(11.67, 70.0, 128.3)),\n));\nv1.add_membership(MF::new(\n    \"L\".to_string(),\n    MFKind::Triangle(Triangle::new(81.67, 140.0, 198.3)),\n));\nfis.add_input(v1);\n</code></pre> <p>distance: S - M - L</p> <pre><code>let mut v2 = InputVariable::new(\"Distance\".to_string(), (0.0, 50.0));\nv2.add_membership(MF::new(\n    \"S\".to_string(),\n    MFKind::Triangle(Triangle::new(-20.83, 0.0, 20.83)),\n));\nv2.add_membership(MF::new(\n    \"M\".to_string(),\n    MFKind::Triangle(Triangle::new(4.168, 25.0, 45.82)),\n));\nv2.add_membership(MF::new(\n    \"L\".to_string(),\n    MFKind::Triangle(Triangle::new(29.17, 50.0, 70.82)),\n));\nfis.add_input(v2);\n</code></pre>"},{"location":"examples/speed_control/#outputs","title":"Outputs","text":"<p>We have to control the acceleration so I will assume the accusation will change between [-1 1]. I choose 5 Gaussian membership function for acceleration.</p> <p>acceleration: NB(negative big) - NS(negative small) - ZR(zero) - PS(positive small) - PB(positive big)</p> <pre><code>let mut o1 = OutputVariable::new(String::from(\"Acceleration\"), (-1.0, 1.0), 100);\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"NB\".to_string(),\n    -1.0,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"NS\".to_string(),\n    -0.5,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"ZR\".to_string(),\n    0.0,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"PS\".to_string(),\n    0.5,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"PB\".to_string(),\n    1.0,\n    0.2123,\n));\nfis.add_input(o1);\n</code></pre>"},{"location":"examples/speed_control/#rules","title":"Rules","text":"<p>We can define the rules as follows:</p> <ol> <li>IF speed IS S AND distance IS S Then acceleration is ZR</li> <li>IF speed IS S AND distance IS M Then acceleration is PS</li> <li>IF speed IS S AND distance IS L Then acceleration is PB</li> <li>IF speed IS M AND distance IS S Then acceleration is NS</li> <li>IF speed IS M AND distance IS M Then acceleration is ZR</li> <li>IF speed IS M AND distance IS L Then acceleration is PS</li> <li>IF speed IS L AND distance IS S Then acceleration is NB</li> <li>IF speed IS L AND distance IS M Then acceleration is NS</li> <li>IF speed IS L AND distance IS L Then acceleration is ZR</li> </ol> <p>We can define the rules:</p> <pre><code>fis.add_rule(Rule::new_and(vec![0, 0, 2], 1.0));\nfis.add_rule(Rule::new_and(vec![0, 1, 3], 1.0));\nfis.add_rule(Rule::new_and(vec![0, 2, 4], 1.0));\n\nfis.add_rule(Rule::new_and(vec![1, 0, 1], 1.0));\nfis.add_rule(Rule::new_and(vec![1, 1, 2], 1.0));\nfis.add_rule(Rule::new_and(vec![1, 2, 3], 1.0));\n\nfis.add_rule(Rule::new_and(vec![2, 0, 0], 1.0));\nfis.add_rule(Rule::new_and(vec![2, 1, 1], 1.0));\nfis.add_rule(Rule::new_and(vec![2, 2, 2], 1.0));\n</code></pre> <p>Weights and Complements</p> <p>You can change weights and changing the second argument, and you can add <code>-</code> sign to complement that variables</p>"},{"location":"examples/speed_control/#output","title":"Output","text":"<p>The problem formulation is done and we can use this to compute the output of the system:</p> <pre><code>let output = fis.compute_outputs(vec![40.0, 43.0]);\nprintln!(\"{:#?}\", output);\n</code></pre> <p>If we run it the output will be:</p> <pre><code>&gt;cargo run --example speed-control \n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target\\debug\\examples\\speed-control.exe`\n[\n    0.45999999999999996,\n]\n</code></pre>"},{"location":"examples/tipper/","title":"Will be add soon!","text":""}]}