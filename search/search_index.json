{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"fuzzy-logic_rs","text":"<p>This is the documentation for fuzzy logic crate.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>    cargo add fuzzy-logic_rs\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>src/\n    lib.rs\n    aggregations.rs\n    defuzzification.rs\n    fuzzy_inference_systems.rs\n    implications.rs\n    membership_functions.rs\n    membership_ranges.rs\n    rules.rs\n    s_norms.rs\n    t_torms.rs\n    variables.rs\nCargo.toml\n.gitignore\nreadme.md\nLICENSE\n-- mkdocs files\n</code></pre>"},{"location":"#inference-systems","title":"Inference Systems","text":"<ul> <li>[*] Mamdani Type 1</li> <li>[ ] Mamdani Type 2</li> <li>[ ] TSK Type 1</li> <li>[ ] TSK Type 2</li> </ul>"},{"location":"#future-plans","title":"Future Plans","text":"<ul> <li>[ ] Import and Export systems to and from a file</li> <li>[ ] Add plot support</li> <li>[ ] add meta-heuristics</li> <li>[ ] add ANFIS support</li> <li>[ ] add dedicated control module</li> <li>[ ] add fuzzy c-means</li> </ul>"},{"location":"docs/doc1/","title":"Functions and Structs and Enums","text":""},{"location":"docs/doc1/#fuzzy_inference_systemsrs","title":"fuzzy_inference_systems.rs","text":""},{"location":"docs/doc1/#mamdanifis","title":"MamdaniFIS","text":"<p>This is Mamdani Inference system</p> <pre><code>  pub struct MamdaniFuzzyInferenceSystem {\n    s_norm: SNorms,\n    t_norm: TNorms,\n    implication: Implications,\n    aggregation: Aggregations,\n    defuzzifier: Defuzzifiers,\n    rules: Vec&lt;Rule&gt;,\n    inputs: Vec&lt;InputVariables&gt;,\n    outputs: Vec&lt;OutputVariables&gt;,\n  }\n</code></pre> <p>You can create a this system using <code>::new</code> method witch is defined as</p> <pre><code>pub fn new(\n        s_norm: SNorms,\n        t_norm: TNorms,\n        implication: Implications,\n        aggregation: Aggregations,\n        defuzzifier: Defuzzifiers,\n    ) -&gt; Self\n</code></pre> <p>Each of these fields are documented separately.</p> <p>To add an input you must use <code>add_input</code> method. It needs an <code>InputVariables</code>.</p> <pre><code>pub fn add_input(&amp;mut self, input: InputVariables)\n</code></pre> <p>The same is true for output but it needs an <code>OutputVariables</code>.</p> <pre><code>pub fn add_output(&amp;mut self, output: OutputVariables)\n</code></pre> <p>To add fuzzy rules you can use <code>add_rule</code> which accepts a <code>Rule</code> struct as an input</p> <pre><code>pub fn add_rule(&amp;mut self, rule: Rule)\n</code></pre> <p>After defining the instance, inputs, outputs, and rules, you can use compute the system output using the <code>compute_output</code> which excepts a <code>vec&lt;f64&gt;</code> of input variables and outputs a <code>vec&lt;f64&gt;</code> containing output variables.</p> <p>Note</p> <p>please note that the inputs must be in the order of when you use <code>add_input</code> method, and outputs will be in the same order as you add them.</p> <pre><code>pub fn compute_outputs(&amp;self, input_vec: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt;\n</code></pre>"},{"location":"docs/doc1/#s_normsrs","title":"s_norms.rs","text":"<p>S-norms are used in FIS systems to compute many thing. In this crate I used it as <code>or</code> method in the rules. It is defined as bellow:</p> <pre><code>pub enum SNorms {\n    Max,\n    Custom(fn (&amp;[f64])-&gt;f64),\n}\n</code></pre> <p>To use default s-norms you can use the <code>Snorms::Max</code>.</p> <p>Right now only <code>Max</code> is defined by default, but you can add a custom s-norm method by defining a function who's signature is like the enum.</p>"},{"location":"docs/doc1/#t_normsrs","title":"t_norms.rs","text":"<p>T-norms are used in FIS systems to compute many thing. In this crate I used it as <code>and</code> method in the rules. You can use t-norms as the same as s-norms.</p> <pre><code>pub enum TNorms {\n    Min,\n    Product,\n    Custom(fn(&amp;[f64]) -&gt; f64),\n}\n</code></pre>"},{"location":"docs/doc1/#implicationsrs","title":"implications.rs","text":"<p>Implication is the act of computing the overall membership of the rule for example</p> \\[ IF \\ x_1 \\ IS \\ \\mu_1 \\ AND \\ x_2 \\ IS \\mu_2 \\ THEN \\ output \\ IS \\ \\mu_o \\] <p>In this form the output of implication is how much the IF part belong to this rule and how is the output membership looks. It is defined as:</p> <pre><code>pub enum Implications {\n    Min,\n    Product,\n    Custom(fn(f64, &amp;Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt;),\n}\n</code></pre> <p>More Implication methods</p> <p>More implication methods will be added in the future like <code>Godel</code> or <code>Zadeh</code>.</p> <p>Use of this is the same as t-norms and s-norms and you can define your own methods for implications.</p> <p>The 1st parameter of the custom function is \\(\\mu\\) and the 2nd argument is an output range.</p>"},{"location":"docs/doc1/#rulesrs","title":"rules.rs","text":"<p>You can define a rule whit:</p> <pre><code>pub struct Rule {\n    relations: Vec&lt;i32&gt;,\n    weight: f64,\n    method: Kind,\n}\n</code></pre> <p>there are two ways to add new rules <code>add_or</code> and <code>add_and</code>. The relations vec is defined as in a rule how the inputs interact with each other.</p> <p>You can change the weight to a value between [0.0 1.0].</p> <p>You can complement(i.e. <code>is not</code>) a membership function or a range by adding a <code>-</code> sign in front of it.</p>"},{"location":"docs/doc1/#aggregationrs","title":"aggregation.rs","text":"<p>Aggregation is the how to compute the overall membership of the output. Basically each rule will produce a range and how to convert them to a single membership range is the overall shape will looks.</p> <pre><code>pub enum Aggregations {\n    Max,\n    Sum,\n    Custom(fn(Vec&lt;Vec&lt;f64&gt;&gt;) -&gt; Vec&lt;f64&gt;)\n}\n</code></pre> <p>You can use it just like previous methods.</p>"},{"location":"docs/doc1/#defuzzificationrs","title":"defuzzification.rs","text":"<p>This is the process in which the fuzzy number is converted back to a crisp number.</p> <pre><code>pub enum Defuzzifiers {\n    Centroid,\n    Bisection,\n    Custom(fn(Vec&lt;f64&gt;,&amp;Vec&lt;f64&gt;)-&gt;f64),\n}\n</code></pre> <p>It is used as before.</p> <p>More defuzzification methods</p> <p>More defuzzification method will be added in the future like <code>CenterOfMeans</code> or <code>MeanOfMax</code>.</p>"},{"location":"docs/doc1/#variablesrs","title":"variables.rs","text":""},{"location":"docs/doc1/#inputvariable","title":"InputVariable","text":"<p>To define a input variable you have to use this struct.</p> <pre><code>pub struct InputVariables {\n    name: String,\n    range: (f64, f64),\n    mfs: Vec&lt;MembershipFunction&gt;,\n}\n</code></pre> <p>You need to use <code>::new()</code> to make a new input variable. Range is the range in which this variable is valid.</p> <p>range</p> <p>There is no restrictions on range now but in the future this will change.</p> <pre><code>pub fn new(name: String, range: (f64, f64)) -&gt; Self \n</code></pre> <p>You can add new membership to a variable. Please note that in need to be a <code>MembershipFunction</code></p> <pre><code>pub fn add_membership(&amp;mut self, mf: MembershipFunction)\n</code></pre> <p>To fuzzify a variable(i.e. convert it from a crisp set to a fuzzy set) you can use the function below. This function will get an index of which membership function you want to fuzzify and the value that need to be converted.</p> <pre><code>pub fn fuzzify(&amp;self, idx: usize, x: f64) -&gt; f64 \n</code></pre>"},{"location":"docs/doc1/#outputvariable","title":"OutputVariable","text":"<p>To define an output variable you need to use this struct. It has a vec of membership range and a universe. The <code>universe</code> it the range in which the output is defined and <code>mrs</code> are the ranges of different memberships. Please note that any value outside of <code>universe</code> is not defined.</p> <pre><code>pub struct OutputVariables {\n    name: String,\n    mrs: Vec&lt;MembershipRange&gt;,\n    universe: Vec&lt;f64&gt;,\n}\n</code></pre> <p>You can create a new <code>OutputVariable</code> using <code>::new()</code> which need a range where the universe is defined and, and how many number of points you want tou be in the range whit <code>n</code> argument.</p> <pre><code>pub fn new(name: String, range: (f64, f64), n: i32) -&gt; Self\n</code></pre>"},{"location":"docs/doc1/#membership_functionsrs","title":"membership_functions.rs","text":"<p>This file will defined the membership functions that is used in input variable. Several defaults are defined but you can also define your own.</p> <pre><code>pub struct MembershipFunction {\n    name: String,\n    kind: Kind,\n}\n</code></pre> <p><code>kind</code> is the kind of membership function that you want to use and it defined as an enum.</p> <pre><code>pub enum Kind {\n    Triangle(Triangle),\n    Trapezoid(Trapezoid),\n    LinearZ(LinearZ),\n    LinearS(LinearS),\n    StepDown(StepDown),\n    StepUp(StepUp),\n    Gaussian(Gaussian),\n    DoubleGaussian(DoubleGaussian),\n    Bell(Bell),\n    Normal(Gaussian),\n    Custom(Custom),\n}\n</code></pre> <p>Each of these variants have a dedicated struct that you can make using <code>::new()</code> .</p>"},{"location":"docs/doc1/#membership_rangesrs","title":"membership_ranges.rs","text":"<p>Membership ranges are used to define an output.</p> <pre><code>pub struct MembershipRange {\n    name: String,\n    mu: Vec&lt;f64&gt;,\n}\n</code></pre>"},{"location":"docs/doc1/#creating-a-membership-function-or-membership-range","title":"Creating a membership function or membership range","text":"<p>They have basically the same. You can create a new using the syntax <code>::new_&lt;what_kind&gt;</code> and add appropriate arguments to it. Please follow the function signature or check out the example for more information.</p>"},{"location":"examples/speed_control/","title":"Overview","text":"<p>In This example we will solving a problem in which we want to control the acceleration of car.</p>"},{"location":"examples/speed_control/#run-the-example","title":"run the example","text":"<p>you can run the example with the following command.</p> <pre><code>cargo run --example speed-control\n</code></pre>"},{"location":"examples/speed_control/#problem-definition","title":"Problem Definition","text":"<p>Control the acceleration of a vehicle using data from speedometer and a radar that measures the distance between the ego vehicle and the vehicle in the front.</p>"},{"location":"examples/speed_control/#import","title":"Import","text":"<p>We will import the necessary modules:</p> <pre><code>use fuzzy_logic_rs::{\n    aggregations::Aggregations,\n    defuzzifications::Defuzzifiers,\n    fuzzy_inference_systems::MamdaniFIS,\n    implications::Implications,\n    membership_functions::{MFKind, Triangle, MF},\n    membership_ranges::MembershipRange,\n    rules::Rule,\n    s_norms::SNorms,\n    t_norms::TNorms,\n    variables::{InputVariables, OutputVariables},\n};\n</code></pre>"},{"location":"examples/speed_control/#setup","title":"Setup","text":"<p>We will using Mamdani FIS with the following configurations.</p> <pre><code>let mut fis = MamdaniFIS::new(\n        SNorms::Max,\n        TNorms::Min,\n        Implications::Min,\n        Aggregations::Max,\n        Defuzzifiers::Bisection,\n    );\n</code></pre>"},{"location":"examples/speed_control/#inputs","title":"Inputs","text":"<p>As the problem stated we have to input that we can use in our calculation, speed and distance. I'll assume the speed will vary in the range of [0 140] and distance in the range of [0 50].</p> <p>Input range</p> <p>please do not use the values outside of these ranges, in the current setup. change the membership that are also defined outside of this range like <code>LinearZ</code> and <code>LinearS</code> or a custom one.</p> <p>I choose 3 triangular membership functions for each input.</p> <p>speed: S - M - L</p> <pre><code>let mut v1 = InputVariables::new(\"speed\".to_string(), (0.0, 140.0));\nv1.add_membership(MF::new(\n    \"S\".to_string(),\n    MFKind::Triangle(Triangle::new(-58.3, 0.0, 58.3)),\n));\nv1.add_membership(MF::new(\n    \"M\".to_string(),\n    MFKind::Triangle(Triangle::new(11.67, 70.0, 128.3)),\n));\nv1.add_membership(MF::new(\n    \"L\".to_string(),\n    MFKind::Triangle(Triangle::new(81.67, 140.0, 198.3)),\n));\nfis.add_input(v1);\n</code></pre> <p>distance: S - M - L</p> <pre><code>let mut v2 = InputVariables::new(\"Distance\".to_string(), (0.0, 50.0));\nv2.add_membership(MF::new(\n    \"S\".to_string(),\n    MFKind::Triangle(Triangle::new(-20.83, 0.0, 20.83)),\n));\nv2.add_membership(MF::new(\n    \"M\".to_string(),\n    MFKind::Triangle(Triangle::new(4.168, 25.0, 45.82)),\n));\nv2.add_membership(MF::new(\n    \"L\".to_string(),\n    MFKind::Triangle(Triangle::new(29.17, 50.0, 70.82)),\n));\nfis.add_input(v2);\n</code></pre>"},{"location":"examples/speed_control/#outputs","title":"Outputs","text":"<p>We have to control the acceleration so I will assume the accusation will change between [-1 1]. I choose 5 Gaussian membership function for acceleration.</p> <p>acceleration: NB(negative big) - NS(negative small) - ZR(zero) - PS(positive small) - PB(positive big)</p> <pre><code>let mut o1 = OutputVariables::new(String::from(\"Acceleration\"), (-1.0, 1.0), 100);\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"NB\".to_string(),\n    -1.0,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"NS\".to_string(),\n    -0.5,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"ZR\".to_string(),\n    0.0,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"PS\".to_string(),\n    0.5,\n    0.2123,\n));\no1.add_membership(MembershipRange::new_gaussian(\n    o1.get_universe(),\n    \"PB\".to_string(),\n    1.0,\n    0.2123,\n));\nfis.add_input(o1);\n</code></pre>"},{"location":"examples/speed_control/#rules","title":"Rules","text":"<p>We can define the rules as follows:</p> <ol> <li>IF speed IS S AND distance IS S Then acceleration is ZR</li> <li>IF speed IS S AND distance IS M Then acceleration is PS</li> <li>IF speed IS S AND distance IS L Then acceleration is PB</li> <li>IF speed IS M AND distance IS S Then acceleration is NS</li> <li>IF speed IS M AND distance IS M Then acceleration is ZR</li> <li>IF speed IS M AND distance IS L Then acceleration is PS</li> <li>IF speed IS L AND distance IS S Then acceleration is NB</li> <li>IF speed IS L AND distance IS M Then acceleration is NS</li> <li>IF speed IS L AND distance IS L Then acceleration is ZR</li> </ol> <p>We can define the rules:</p> <pre><code>fis.add_rule(Rule::new_and(vec![0, 0, 2], 1.0));\nfis.add_rule(Rule::new_and(vec![0, 1, 3], 1.0));\nfis.add_rule(Rule::new_and(vec![0, 2, 4], 1.0));\n\nfis.add_rule(Rule::new_and(vec![1, 0, 1], 1.0));\nfis.add_rule(Rule::new_and(vec![1, 1, 2], 1.0));\nfis.add_rule(Rule::new_and(vec![1, 2, 3], 1.0));\n\nfis.add_rule(Rule::new_and(vec![2, 0, 0], 1.0));\nfis.add_rule(Rule::new_and(vec![2, 1, 1], 1.0));\nfis.add_rule(Rule::new_and(vec![2, 2, 2], 1.0));\n</code></pre> <p>Weights and Complements</p> <p>You can change weights and changing the second argument, and you can add <code>-</code> sign to complement that variables</p>"},{"location":"examples/speed_control/#output","title":"Output","text":"<p>The problem formulation is done and we can use this to compute the output of the system:</p> <pre><code>let output = fis.compute_outputs(vec![40.0, 43.0]);\nprintln!(\"{:#?}\", output);\n</code></pre> <p>If we run it the output will be:</p> <pre><code>&gt;cargo run --example speed-control \n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target\\debug\\examples\\speed-control.exe`\n[\n    0.45999999999999996,\n]\n</code></pre>"}]}